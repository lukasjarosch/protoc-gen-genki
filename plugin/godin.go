package genki

import (
	"fmt"
	"strings"

	"github.com/lukasjarosch/protoc-gen-genki/generator"
)

func init() {
	generator.RegisterPlugin(new(genki))
}

type genki struct {
	gen *generator.Generator
}

func (g *genki) Name() string {
	return "genki"
}

// P forwards to g.gen.P.
func (g *genki) P(args ...interface{}) { g.gen.P(args...) }

// Init will initalize the genki plugin
func (g *genki) Init(gen *generator.Generator) {
	g.gen = gen
}

func (g *genki) Generate(file *generator.FileDescriptor) {
	for _, service := range file.Service {
		clientInterfaceName := fmt.Sprintf("%sClient", service.GetName()) // this name is generated by the grpc plugin (e.g.: "ExampleServiceClient")
		clientTypeName := fmt.Sprintf("%sGenkiClient", service.GetName())

		cleanServiceName := strings.ToLower(service.GetName())
		cleanServiceName = strings.Replace(cleanServiceName, "service", "", 1)

		g.P("type ", clientTypeName, " struct {")
		g.P("cc *genkiGrpcClient.Client")
		g.P("service ", clientInterfaceName)
		g.P("}")

		// Factory function with address
		g.P("func New", clientTypeName, "WithAddr(address string) (*", clientTypeName, ", error) {")
		g.P("c := genkiGrpcClient.NewClientWithAddress(\"", cleanServiceName, "\", address)")
		g.P("err := c.Connect()")
		g.P("if err != nil {")
		g.P("return nil, err")
		g.P("}")
		g.P("return &", clientTypeName, "{")
		g.P("	cc: c,")
		g.P("	service: New", clientInterfaceName, "(c.Connection()),")
		g.P("}, nil")
		g.P("}")
		g.P()

		// Factory function with address from flags
		g.P("func New", clientTypeName, "() (*", clientTypeName, ", error) {")
		g.P("c := genkiGrpcClient.NewClient(\"", cleanServiceName, "\")")
		g.P("err := c.Connect()")
		g.P("if err != nil {")
		g.P("return nil, err")
		g.P("}")
		g.P("return &", clientTypeName, "{")
		g.P("	cc: c,")
		g.P("	service: New", clientInterfaceName, "(c.Connection()),")
		g.P("}, nil")
		g.P("}")
		g.P()

		for _, meth := range service.Method {
			requestTypeName := g.typeName(meth.GetInputType())
			responseTypeName := g.typeName(meth.GetOutputType())
			methodName := meth.GetName()

			g.P("// ", methodName, " will call ", file.GetPackage(), ".", service.GetName(), ".", methodName, "()")
			g.P("func (client *", clientTypeName, ") ", methodName, "(ctx context.Context, request *", requestTypeName, ") (response *", responseTypeName, ", err error) {")
			g.P("ctx = genkiMeta.NewOutgoingContext(ctx)")
			g.P("req, err := client.service.", methodName, "(ctx, request)")
			g.P("if err != nil {")
			g.P("return nil, err")
			g.P("}")
			g.P("return req, nil")
			g.P("}")
			g.P()
		}

		// func Connect() (err error)
		g.P("// Connect is a wrapper to the underlying genki client Connect() call")
		g.P("func (client *", clientTypeName, ") Connect() (err error) {")
		g.P("return client.cc.Connect()")
		g.P("}")
		g.P()

		// func Connection() *grpc.ClientConn
		g.P("// Connection is a wrapper to the underlying genki client Connection() call")
		g.P("func (client *", clientTypeName, ") Connection() *grpc.ClientConn {")
		g.P("return client.cc.Connection()")
		g.P("}")
		g.P()

		// func Disconnect()
		g.P("// Disconnect is a wrapper to the underlying genki client Disconnect() call")
		g.P("func (client *", clientTypeName, ") Disconnect() {")
		g.P("client.cc.Disconnect()")
		g.P("}")
		g.P()

		// func Flags *pflag.Flagset()
		g.P("// Flags is a wrapper to the underlying genki client Flags() call")
		g.P("func GenkiClientFlags() *pflag.FlagSet {")
		g.P("c := genkiGrpcClient.NewClient(\"", cleanServiceName, "\")")
		g.P("return c.Flags()")
		g.P("}")
		g.P()

	}
}

func (g *genki) GenerateImports(file *generator.FileDescriptor) {
	if len(file.FileDescriptorProto.Service) == 0 {
		return
	}
	g.P("import (")
	g.P("genkiMeta \"github.com/lukasjarosch/genki/metadata\"")
	g.P("genkiGrpcClient \"github.com/lukasjarosch/genki/client/grpc\"")
	g.P("\"github.com/spf13/pflag\"")
	g.P("\"context\"")
	g.P("\"google.golang.org/grpc\"")
	g.P(")")
	g.P()
}

// Given a type name defined in a .proto, return its object.
// Also record that we're using it, to guarantee the associated import.
func (g *genki) objectNamed(name string) generator.Object {
	g.gen.RecordTypeUse(name)
	return g.gen.ObjectNamed(name)
}

// Return the printable name of a type (e.g. InputType)
func (g *genki) typeName(str string) string {
	return g.gen.TypeName(g.objectNamed(str))
}
